// Generated by CoffeeScript 1.4.0

/*
Data types
  floats are an array (length 1) of a number
  vectors are arrays of numbers
*/


(function() {
  var builtin, clamp, evaluate, makeEnv, makeEnvFromHash, n, vec, zip,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  zip = function(f) {
    return function() {
      var i, maxLength, numbers, param, params, _i, _j, _len, _results;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      maxLength = 0;
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        param = params[_i];
        maxLength = Math.max(maxLength, param.length);
      }
      _results = [];
      for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
        numbers = (function() {
          var _k, _len1, _results1;
          _results1 = [];
          for (_k = 0, _len1 = params.length; _k < _len1; _k++) {
            param = params[_k];
            _results1.push(param[i % param.length]);
          }
          return _results1;
        })();
        _results.push(f.apply(null, numbers));
      }
      return _results;
    };
  };

  vec = function(size) {
    return function() {
      var component, param, params, result, _i, _j, _len, _len1;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = [];
      while (result.length < size) {
        for (_i = 0, _len = params.length; _i < _len; _i++) {
          param = params[_i];
          for (_j = 0, _len1 = param.length; _j < _len1; _j++) {
            component = param[_j];
            result.push(component);
          }
        }
      }
      return result.slice(0, size);
    };
  };

  n = {
    add: zip(function(x, y) {
      return x + y;
    }),
    sub: zip(function(x, y) {
      return x - y;
    }),
    mul: zip(function(x, y) {
      return x * y;
    }),
    div: zip(function(x, y) {
      return x / y;
    })
  };

  clamp = function(x, minVal, maxVal) {
    return min(max(x, minVal), maxVal);
  };

  builtin = {
    float: vec(1),
    vec2: vec(2),
    vec3: vec(3),
    vec4: vec(4),
    abs: zip(Math.abs),
    mod: zip(function(x, y) {
      return x - y * Math.floor(x / y);
    }),
    floor: zip(Math.floor),
    ceil: zip(Math.ceil),
    sin: zip(Math.sin),
    cos: zip(Math.cos),
    tan: zip(Math.tan),
    min: zip(Math.min),
    max: zip(Math.max),
    clamp: zip(clamp),
    exp: zip(Math.exp),
    pow: zip(Math.pow),
    sqrt: zip(Math.sqrt),
    fract: zip(function(x) {
      return x - Math.floor(x);
    }),
    step: zip(function(edge, x) {
      if (x < edge) {
        return 0;
      } else {
        return 1;
      }
    }),
    smoothstep: zip(function(edge0, edge1, x) {
      var t;
      t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
      return t * t * (3.0 - 2.0 * t);
    })
  };

  makeEnv = function() {
    var env, store;
    store = {};
    env = {};
    env.get = function(key) {
      return store[key];
    };
    env.set = function(key, value) {
      return store[key] = value;
    };
    return env;
  };

  makeEnvFromHash = function(hash) {
    var env, k, v;
    env = makeEnv();
    for (k in hash) {
      if (!__hasProp.call(hash, k)) continue;
      v = hash[k];
      env.set(k, v);
    }
    return env;
  };

  evaluate = function(env, ast) {
    var evaluatedParameters, function_name, name, operator, parameter, type;
    type = ast.type;
    if (type === "identifier") {
      name = ast.name;
      return ast.evaluated = env.get(name);
    } else if (type === "float") {
      return ast.evaluated = [ast.value];
    } else if (type === "unary") {
      operator = ast.operator.operator;
      evaluate(env, ast.expression);
      if (operator === "-") {
        return ast.evaluated = n.mul(-1, ast.expression.evaluated);
      } else if (operator === "+") {
        return ast.evaluated = ast.expression.evaluated;
      } else {
        throw "Unsupported unary operator: " + operator;
      }
    } else if (type === "binary") {
      operator = ast.operator.operator;
      evaluate(env, ast.left);
      evaluate(env, ast.right);
      if (operator === "+") {
        return ast.evaluated = n.add(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "-") {
        return ast.evaluated = n.sub(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "*") {
        return ast.evaluated = n.mul(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "/") {
        return ast.evaluated = n.div(ast.left.evaluated, ast.right.evaluated);
      } else {
        throw "Unsupported binary operator: " + operator;
      }
    } else if (type === "function_call") {
      function_name = ast.function_name;
      if (builtin[function_name]) {
        evaluatedParameters = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.parameters;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            parameter = _ref[_i];
            evaluate(env, parameter);
            _results.push(parameter.evaluated);
          }
          return _results;
        })();
        return ast.evaluated = builtin[function_name].apply(builtin, evaluatedParameters);
      } else {
        throw "Unsupported function: " + function_name;
      }
    } else {
      throw "Unsupported type: " + type;
    }
  };

  module.exports = function(hash, ast) {
    var env;
    env = makeEnvFromHash(hash);
    return evaluate(env, ast);
  };

}).call(this);
