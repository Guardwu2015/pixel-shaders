// Generated by CoffeeScript 1.4.0

/*
Data types
  floats are an array (length 1) of a number
  vectors are arrays of numbers
*/


(function() {
  var builtin, clamp, evaluate, extractStatements, floatToString, makeEnv, makeEnvFromHash, operators, select, selectionComponents, vec, vecToString, zip, _,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  _ = require("underscore");

  zip = function(f) {
    return function() {
      var i, maxLength, numbers, param, params, _i, _j, _len, _results;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      maxLength = 0;
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        param = params[_i];
        maxLength = Math.max(maxLength, param.length);
      }
      _results = [];
      for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
        numbers = (function() {
          var _k, _len1, _results1;
          _results1 = [];
          for (_k = 0, _len1 = params.length; _k < _len1; _k++) {
            param = params[_k];
            _results1.push(param[i % param.length]);
          }
          return _results1;
        })();
        _results.push(f.apply(null, numbers));
      }
      return _results;
    };
  };

  vec = function(size) {
    return function() {
      var component, param, params, result, _i, _j, _len, _len1;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = [];
      while (result.length < size) {
        for (_i = 0, _len = params.length; _i < _len; _i++) {
          param = params[_i];
          for (_j = 0, _len1 = param.length; _j < _len1; _j++) {
            component = param[_j];
            result.push(component);
          }
        }
      }
      return result.slice(0, size);
    };
  };

  selectionComponents = {
    x: 0,
    y: 1,
    z: 2,
    w: 3,
    r: 0,
    g: 1,
    b: 2,
    a: 3,
    s: 0,
    t: 1,
    p: 2,
    q: 3
  };

  select = function(x, selection) {
    var char, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = selection.length; _i < _len; _i++) {
      char = selection[_i];
      _results.push(x[selectionComponents[char]]);
    }
    return _results;
  };

  operators = {
    add: zip(function(x, y) {
      return x + y;
    }),
    sub: zip(function(x, y) {
      return x - y;
    }),
    mul: zip(function(x, y) {
      return x * y;
    }),
    div: zip(function(x, y) {
      return x / y;
    })
  };

  clamp = function(x, minVal, maxVal) {
    return min(max(x, minVal), maxVal);
  };

  builtin = {
    float: vec(1),
    vec2: vec(2),
    vec3: vec(3),
    vec4: vec(4),
    abs: zip(Math.abs),
    mod: zip(function(x, y) {
      return x - y * Math.floor(x / y);
    }),
    floor: zip(Math.floor),
    ceil: zip(Math.ceil),
    sin: zip(Math.sin),
    cos: zip(Math.cos),
    tan: zip(Math.tan),
    min: zip(Math.min),
    max: zip(Math.max),
    clamp: zip(clamp),
    exp: zip(Math.exp),
    pow: zip(Math.pow),
    sqrt: zip(Math.sqrt),
    fract: zip(function(x) {
      return x - Math.floor(x);
    }),
    step: zip(function(edge, x) {
      if (x < edge) {
        return 0;
      } else {
        return 1;
      }
    }),
    smoothstep: zip(function(edge0, edge1, x) {
      var t;
      t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
      return t * t * (3.0 - 2.0 * t);
    })
  };

  makeEnv = function() {
    var env, store;
    store = {};
    env = {};
    env.get = function(key) {
      return store[key];
    };
    env.set = function(key, value) {
      return store[key] = value;
    };
    return env;
  };

  makeEnvFromHash = function(hash) {
    var env, k, v;
    env = makeEnv();
    for (k in hash) {
      if (!__hasProp.call(hash, k)) continue;
      v = hash[k];
      env.set(k, v);
    }
    return env;
  };

  evaluate = function(env, ast) {
    var evaluatedParameters, function_name, name, operator, operator_type, parameter, selection, statement, type, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
    type = ast.type;
    if (type === "root") {
      _ref = ast.statements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        statement = _ref[_i];
        _results.push(evaluate(env, statement));
      }
      return _results;
    } else if (type === "precision") {

    } else if (type === "declarator") {

    } else if (type === "function_declaration") {
      if (ast.name === "main") {
        return evaluate(env, ast.body);
      } else {

      }
    } else if (type === "scope") {
      _ref1 = ast.statements;
      _results1 = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        statement = _ref1[_j];
        _results1.push(evaluate(env, statement));
      }
      return _results1;
    } else if (type === "expression") {
      evaluate(env, ast.expression);
      return ast.evaluated = ast.expression.evaluated;
    } else if (type === "identifier") {
      name = ast.name;
      return ast.evaluated = env.get(name);
    } else if (type === "float") {
      return ast.evaluated = [ast.value];
    } else if (type === "postfix") {
      operator_type = ast.operator.type;
      if (operator_type === "field_selector") {
        selection = ast.operator.selection;
        evaluate(env, ast.expression);
        return ast.evaluated = select(ast.expression.evaluated, selection);
      } else {
        throw "Unsupported postfix operator: " + operator_type;
      }
    } else if (type === "unary") {
      operator = ast.operator.operator;
      evaluate(env, ast.expression);
      if (operator === "-") {
        return ast.evaluated = operators.mul([-1], ast.expression.evaluated);
      } else if (operator === "+") {
        return ast.evaluated = ast.expression.evaluated;
      } else {
        throw "Unsupported unary operator: " + operator;
      }
    } else if (type === "binary") {
      operator = ast.operator.operator;
      if (operator !== "=") {
        evaluate(env, ast.left);
      }
      evaluate(env, ast.right);
      if (operator === "=") {
        return ast.evaluated = ast.right.evaluated;
      } else if (operator === "+") {
        return ast.evaluated = operators.add(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "-") {
        return ast.evaluated = operators.sub(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "*") {
        return ast.evaluated = operators.mul(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "/") {
        return ast.evaluated = operators.div(ast.left.evaluated, ast.right.evaluated);
      } else {
        throw "Unsupported binary operator: " + operator;
      }
    } else if (type === "function_call") {
      function_name = ast.function_name;
      if (builtin[function_name]) {
        evaluatedParameters = (function() {
          var _k, _len2, _ref2, _results2;
          _ref2 = ast.parameters;
          _results2 = [];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            parameter = _ref2[_k];
            evaluate(env, parameter);
            _results2.push(parameter.evaluated);
          }
          return _results2;
        })();
        return ast.evaluated = builtin[function_name].apply(builtin, evaluatedParameters);
      } else {
        throw "Unsupported function: " + function_name;
      }
    } else {
      throw "Unsupported type: " + type;
    }
  };

  module.exports = function(hash, ast) {
    var env;
    env = makeEnvFromHash(hash);
    return evaluate(env, ast);
  };

  floatToString = function(n, significantDigits) {
    var s;
    s = n.toFixed(significantDigits);
    if (!s.indexOf(".")) {
      s = s + ".";
    }
    return s.replace(/0+$/, "");
  };

  vecToString = function(x, significantDigits) {
    var fts, n, s;
    fts = function(n) {
      return floatToString(n, significantDigits);
    };
    if (x.length === 1) {
      return fts(x[0]);
    } else {
      s = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          n = x[_i];
          _results.push(fts(n));
        }
        return _results;
      })()).join(", ");
      return "vec" + x.length + "(" + s + ")";
    }
  };

  extractStatements = function(ast, result) {
    var a, k, statement, v, _i, _j, _len, _len1, _ref;
    if (result == null) {
      result = [];
    }
    if (ast.statements) {
      _ref = ast.statements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        statement = _ref[_i];
        if (statement.evaluated) {
          result.push({
            line: statement.line - 1,
            message: vecToString(statement.evaluated, 5)
          });
        }
      }
    }
    if (_.isObject(ast)) {
      for (k in ast) {
        if (!__hasProp.call(ast, k)) continue;
        v = ast[k];
        extractStatements(v, result);
      }
    } else if (_.isArray(ast)) {
      for (_j = 0, _len1 = ast.length; _j < _len1; _j++) {
        a = ast[_j];
        extractStatements(a, result);
      }
    }
    return result;
  };

  module.exports.extractStatements = extractStatements;

}).call(this);
