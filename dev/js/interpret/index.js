// Generated by CoffeeScript 1.4.0

/*
Data types
  floats are an array (length 1) of a number
  vectors are arrays of numbers
*/


(function() {
  var builtin, defaultValue, evaluate, extractStatements, floatToString, makeEnv, makeEnvFromHash, operators, round, select, selectionComponents, setAll, setSelection, vec, vecToString, zip, _,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  _ = require("underscore");

  zip = function(f) {
    return function() {
      var i, maxLength, numbers, param, params, _i, _j, _len, _results;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      maxLength = 0;
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        param = params[_i];
        maxLength = Math.max(maxLength, param.length);
      }
      _results = [];
      for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
        numbers = (function() {
          var _k, _len1, _results1;
          _results1 = [];
          for (_k = 0, _len1 = params.length; _k < _len1; _k++) {
            param = params[_k];
            _results1.push(param[i % param.length]);
          }
          return _results1;
        })();
        _results.push(f.apply(null, numbers));
      }
      return _results;
    };
  };

  vec = function(size) {
    return function() {
      var component, param, params, result, _i, _j, _len, _len1;
      params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = [];
      while (result.length < size) {
        for (_i = 0, _len = params.length; _i < _len; _i++) {
          param = params[_i];
          for (_j = 0, _len1 = param.length; _j < _len1; _j++) {
            component = param[_j];
            result.push(component);
          }
        }
      }
      return result.slice(0, size);
    };
  };

  defaultValue = function(type) {
    var defaults;
    defaults = {
      float: [0],
      vec2: [0, 0],
      vec3: [0, 0, 0],
      vec4: [0, 0, 0, 0]
    };
    return defaults[type].slice(0);
  };

  selectionComponents = {
    x: 0,
    y: 1,
    z: 2,
    w: 3,
    r: 0,
    g: 1,
    b: 2,
    a: 3,
    s: 0,
    t: 1,
    p: 2,
    q: 3
  };

  select = function(x, selection) {
    var char, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = selection.length; _i < _len; _i++) {
      char = selection[_i];
      _results.push(x[selectionComponents[char]]);
    }
    return _results;
  };

  setSelection = function(vec, assign, selection) {
    var char, i, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = selection.length; _i < _len; i = ++_i) {
      char = selection[i];
      _results.push(vec[selectionComponents[char]] = assign[i]);
    }
    return _results;
  };

  setAll = function(vec, assign) {
    var component, i, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = vec.length; _i < _len; i = ++_i) {
      component = vec[i];
      _results.push(vec[i] = assign[i % assign.length]);
    }
    return _results;
  };

  operators = {
    add: zip(function(x, y) {
      return x + y;
    }),
    sub: zip(function(x, y) {
      return x - y;
    }),
    mul: zip(function(x, y) {
      return x * y;
    }),
    div: zip(function(x, y) {
      return x / y;
    })
  };

  builtin = (function() {
    var clamp, length;
    clamp = function(x, minVal, maxVal) {
      return min(max(x, minVal), maxVal);
    };
    length = function(v) {
      var component, total, _i, _len;
      total = 0;
      for (_i = 0, _len = v.length; _i < _len; _i++) {
        component = v[_i];
        total += component * component;
      }
      return [Math.sqrt(total)];
    };
    return {
      float: vec(1),
      vec2: vec(2),
      vec3: vec(3),
      vec4: vec(4),
      length: length,
      distance: function(v, w) {
        return length(operators.sub(v, w));
      },
      abs: zip(Math.abs),
      mod: zip(function(x, y) {
        return x - y * Math.floor(x / y);
      }),
      floor: zip(Math.floor),
      ceil: zip(Math.ceil),
      sin: zip(Math.sin),
      cos: zip(Math.cos),
      tan: zip(Math.tan),
      min: zip(Math.min),
      max: zip(Math.max),
      clamp: zip(clamp),
      exp: zip(Math.exp),
      pow: zip(Math.pow),
      sqrt: zip(Math.sqrt),
      fract: zip(function(x) {
        return x - Math.floor(x);
      }),
      step: zip(function(edge, x) {
        if (x < edge) {
          return 0;
        } else {
          return 1;
        }
      }),
      smoothstep: zip(function(edge0, edge1, x) {
        var t;
        t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        return t * t * (3.0 - 2.0 * t);
      })
    };
  })();

  makeEnv = function() {
    var env, store;
    store = {};
    env = {};
    env.get = function(key) {
      return store[key];
    };
    env.set = function(key, value) {
      return store[key] = value;
    };
    return env;
  };

  makeEnvFromHash = function(hash) {
    var env, k, v;
    env = makeEnv();
    for (k in hash) {
      if (!__hasProp.call(hash, k)) continue;
      v = hash[k];
      env.set(k, v);
    }
    return env;
  };

  evaluate = function(env, ast) {
    var declarator, declaredType, evaluatedParameters, function_name, name, operator, operator_type, parameter, selection, statement, type, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results, _results1, _results2;
    type = ast.type;
    if (type === "root") {
      _ref = ast.statements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        statement = _ref[_i];
        _results.push(evaluate(env, statement));
      }
      return _results;
    } else if (type === "precision") {

    } else if (type === "declarator") {
      declaredType = ast.typeAttribute.name;
      _ref1 = ast.declarators;
      _results1 = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        declarator = _ref1[_j];
        name = declarator.name.name;
        if (env.get(name)) {
          _results1.push(ast.evaluated = env.get(name));
        } else {
          env.set(name, defaultValue(declaredType));
          if (declarator.initializer) {
            evaluate(env, declarator.initializer);
            setAll(env.get(name), declarator.initializer.evaluated);
            _results1.push(ast.evaluated = declarator.initializer.evaluated);
          } else {
            _results1.push(void 0);
          }
        }
      }
      return _results1;
    } else if (type === "function_declaration") {
      if (ast.name === "main") {
        return evaluate(env, ast.body);
      } else {

      }
    } else if (type === "scope") {
      _ref2 = ast.statements;
      _results2 = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        statement = _ref2[_k];
        _results2.push(evaluate(env, statement));
      }
      return _results2;
    } else if (type === "expression") {
      if (ast.expression !== "") {
        evaluate(env, ast.expression);
        return ast.evaluated = ast.expression.evaluated;
      }
    } else if (type === "identifier") {
      name = ast.name;
      return ast.evaluated = env.get(name);
    } else if (type === "float") {
      return ast.evaluated = [ast.value];
    } else if (type === "postfix") {
      operator_type = ast.operator.type;
      if (operator_type === "field_selector") {
        selection = ast.operator.selection;
        evaluate(env, ast.expression);
        return ast.evaluated = select(ast.expression.evaluated, selection);
      } else {
        throw "Unsupported postfix operator: " + operator_type;
      }
    } else if (type === "unary") {
      operator = ast.operator.operator;
      evaluate(env, ast.expression);
      if (operator === "-") {
        return ast.evaluated = operators.mul([-1], ast.expression.evaluated);
      } else if (operator === "+") {
        return ast.evaluated = ast.expression.evaluated;
      } else {
        throw "Unsupported unary operator: " + operator;
      }
    } else if (type === "binary") {
      operator = ast.operator.operator;
      if (operator !== "=") {
        evaluate(env, ast.left);
      }
      evaluate(env, ast.right);
      if (operator === "=") {
        if (ast.left.type === "postfix") {
          name = ast.left.expression.name;
          selection = ast.left.operator.selection;
          setSelection(env.get(name), ast.right.evaluated, selection);
        } else if (ast.left.type === "identifier") {
          name = ast.left.name;
          setAll(env.get(name), ast.right.evaluated);
        }
        return ast.evaluated = ast.right.evaluated;
      } else if (operator === "+") {
        return ast.evaluated = operators.add(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "-") {
        return ast.evaluated = operators.sub(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "*") {
        return ast.evaluated = operators.mul(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "/") {
        return ast.evaluated = operators.div(ast.left.evaluated, ast.right.evaluated);
      } else {
        throw "Unsupported binary operator: " + operator;
      }
    } else if (type === "function_call") {
      function_name = ast.function_name;
      if (builtin[function_name]) {
        evaluatedParameters = (function() {
          var _l, _len3, _ref3, _results3;
          _ref3 = ast.parameters;
          _results3 = [];
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            parameter = _ref3[_l];
            evaluate(env, parameter);
            _results3.push(parameter.evaluated);
          }
          return _results3;
        })();
        return ast.evaluated = builtin[function_name].apply(builtin, evaluatedParameters);
      } else {
        throw "Unsupported function: " + function_name;
      }
    } else {
      throw "Unsupported type: " + type;
    }
  };

  module.exports = function(hash, ast) {
    var env;
    env = makeEnvFromHash(hash);
    return evaluate(env, ast);
  };

  round = function(x, precision) {
    var mult;
    if (precision == null) {
      precision = 3;
    }
    mult = Math.pow(10, precision);
    return Math.round(x * mult) / mult;
  };

  floatToString = function(n, significantDigits) {
    var rounded, s;
    rounded = round(n, 6);
    if (Math.abs(rounded - n) < 1 / Math.pow(10, 9)) {
      n = rounded;
    }
    s = "" + n;
    if (s.indexOf(".") === -1) {
      s = s + ".";
    }
    return s.replace(/0+$/, "");
  };

  vecToString = function(x, significantDigits) {
    var fts, n, s;
    fts = function(n) {
      return floatToString(n, significantDigits);
    };
    if (x.length === 1) {
      return fts(x[0]);
    } else {
      s = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          n = x[_i];
          _results.push(fts(n));
        }
        return _results;
      })()).join(", ");
      return "vec" + x.length + "(" + s + ")";
    }
  };

  extractStatements = function(ast, result) {
    var a, k, statement, v, _i, _j, _len, _len1, _ref;
    if (result == null) {
      result = [];
    }
    if (ast.statements) {
      _ref = ast.statements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        statement = _ref[_i];
        if (statement.evaluated) {
          result.push({
            line: statement.line - 1,
            message: vecToString(statement.evaluated, 5)
          });
        }
      }
    }
    if (_.isObject(ast)) {
      for (k in ast) {
        if (!__hasProp.call(ast, k)) continue;
        v = ast[k];
        extractStatements(v, result);
      }
    } else if (_.isArray(ast)) {
      for (_j = 0, _len1 = ast.length; _j < _len1; _j++) {
        a = ast[_j];
        extractStatements(a, result);
      }
    }
    return result;
  };

  module.exports.vecToString = vecToString;

  module.exports.extractStatements = extractStatements;

}).call(this);
