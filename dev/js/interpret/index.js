// Generated by CoffeeScript 1.4.0

/*
Data types
  floats are an array (length 1) of a number
  vectors are arrays of numbers
*/


(function() {
  var evaluate, makeEnv, n, zip;

  zip = function(f) {
    return function(params) {
      var i, maxLength, numbers, param, _i, _j, _k, _len, _len1, _results;
      maxLength = 0;
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        param = params[_i];
        maxLength = Math.max(maxlength, param.length);
      }
      _results = [];
      for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
        for (_k = 0, _len1 = params.length; _k < _len1; _k++) {
          param = params[_k];
          numbers = param[i % param.length];
        }
        _results.push(f.apply(null, numbers));
      }
      return _results;
    };
  };

  n = {
    add: zip(function(x, y) {
      return x + y;
    }),
    sub: zip(function(x, y) {
      return x - y;
    }),
    mul: zip(function(x, y) {
      return x * y;
    }),
    div: zip(function(x, y) {
      return x / y;
    })
  };

  makeEnv = function() {
    var env, store;
    store = {};
    env = {};
    env.get = function(key) {
      return store[key];
    };
    env.set = function(key, value) {
      return store[key] = value;
    };
    return env;
  };

  evaluate = function(env, ast) {
    var operator, type;
    type = ast.type;
    if (type === "unary") {
      operator = ast.operator.operator;
      evaluate(env, ast.expression);
      if (operator === "-") {
        return ast.evaluated = n.mul(-1, ast.expression.evaluated);
      } else if (operator === "+") {
        return ast.evaluated = ast.expression.evaluated;
      } else {
        throw "Unsupported operator: " + operator;
      }
    } else if (type === "binary") {
      operator = ast.operator.operator;
      evaluate(env, ast.left);
      evaluate(env, ast.right);
      if (operator === "+") {
        return ast.evaluated = n.add(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "-") {
        return ast.evaluated = n.sub(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "*") {
        return ast.evaluated = n.mul(ast.left.evaluated, ast.right.evaluated);
      } else if (operator === "/") {
        return ast.evaluated = n.div(ast.left.evaluated, ast.right.evaluated);
      }
    } else if (type === "function_call") {

    } else {
      throw "Unsupported type: " + type;
    }
  };

  module.exports = evaluate;

}).call(this);
