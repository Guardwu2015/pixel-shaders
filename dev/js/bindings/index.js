// Generated by CoffeeScript 1.4.0
(function() {
  var $, clear, ko, sizeCanvas, vertexShaderSource, _,
    __hasProp = {}.hasOwnProperty;

  ko = require("knockout");

  $ = require("jquery");

  _ = require("underscore");

  clear = function(ctx) {
    var h, w;
    w = ctx.canvas.width;
    h = ctx.canvas.height;
    return ctx.clearRect(0, 0, w, h);
  };

  sizeCanvas = function(canvas) {
    var h, w;
    w = $(canvas).width();
    h = $(canvas).height();
    canvas.width = w;
    return canvas.height = h;
  };

  ko.bindingHandlers.drawGrid = {
    init: function(element, valueAccessor) {
      var ctx, draw, o;
      o = valueAccessor();
      sizeCanvas(element);
      ctx = element.getContext("2d");
      draw = function() {
        var bounds, opts;
        clear(ctx);
        bounds = o.bounds();
        opts = {
          ctx: ctx,
          minX: bounds.minX,
          maxX: bounds.maxX,
          minY: bounds.minY,
          maxY: bounds.maxY,
          flipY: true,
          color: "0,0,0",
          shadow: false
        };
        if (o.color === "white") {
          opts.color = "255,255,255";
          opts.shadow = true;
        } else if (o.color === "black") {
          opts.color = "0,0,0";
          opts.shadow = false;
        }
        return require("graph-grid")(opts);
      };
      return ko.computed(draw);
    }
  };

  ko.bindingHandlers.panAndZoom = {
    init: function(element, valueAccessor) {
      var o, pz;
      o = valueAccessor();
      pz = require("pan-zoom")({
        element: element,
        flipY: true
      });
      ko.computed(function() {
        var bounds;
        bounds = o.bounds();
        pz.minX = bounds.minX;
        pz.maxX = bounds.maxX;
        pz.minY = bounds.minY;
        return pz.maxY = bounds.maxY;
      });
      pz.on("update", function() {
        return o.bounds({
          minX: pz.minX,
          maxX: pz.maxX,
          minY: pz.minY,
          maxY: pz.maxY
        });
      });
      if (o.position) {
        return pz.on("position", function(x, y) {
          return o.position([x, y]);
        });
      }
    }
  };

  ko.bindingHandlers.relPosition = {
    init: function(element, valueAccessor) {
      var $element, o;
      o = valueAccessor();
      $element = $(element);
      return ko.computed(function() {
        var bounds, height, position, width, x, y;
        bounds = o.bounds();
        position = o.position();
        width = $element.parent().width();
        height = $element.parent().height();
        x = width * (position[0] - bounds.minX) / (bounds.maxX - bounds.minX);
        y = height * (1 - (position[1] - bounds.minY)) / (bounds.maxY - bounds.minY);
        $element.css("left", x);
        return $element.css("top", y);
      });
    }
  };

  ko.bindingHandlers.editorShader = {
    init: function(element, valueAccessor) {
      var editor, o;
      o = valueAccessor();
      editor = require("editor")({
        div: element,
        src: o.src(),
        multiline: o.multiline
      });
      editor.on("change", function() {
        return o.src(editor.src());
      });
      o.src.subscribe(function(newSrc) {
        if (newSrc !== editor.src()) {
          return editor.codemirror.setValue(newSrc);
        }
      });
      if (o.errors) {
        ko.computed(function() {
          return editor.set({
            errors: o.errors()
          });
        });
      }
      if (o.annotations) {
        return ko.computed(function() {
          return editor.set({
            annotations: o.annotations()
          });
        });
      }
    }
  };

  ko.bindingHandlers.drawGraph = {
    init: function(element, valueAccessor) {
      var ctx, o;
      o = valueAccessor();
      sizeCanvas(element);
      ctx = element.getContext("2d");
      return ko.computed(function() {
        var bounds, f;
        f = o.f();
        bounds = o.bounds();
        if (f) {
          clear(ctx);
          return require("graph-line")({
            ctx: ctx,
            flipY: true,
            minX: bounds.minX,
            maxX: bounds.maxX,
            minY: bounds.minY,
            maxY: bounds.maxY,
            f: f
          });
        }
      });
    }
  };

  vertexShaderSource = "precision mediump float;\n\nattribute vec3 vertexPosition;\nvarying vec2 position;\nuniform vec2 boundsMin;\nuniform vec2 boundsMax;\n\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  position = mix(boundsMin, boundsMax, (vertexPosition.xy + 1.0) * 0.5);\n}";

  ko.bindingHandlers.drawShader = {
    init: function(element, valueAccessor) {
      var draw, o, shader;
      o = valueAccessor();
      shader = require("shader")({
        canvas: element,
        vertex: vertexShaderSource,
        fragment: o.src()
      });
      element.shader = shader;
      draw = function() {
        return shader.draw();
      };
      ko.computed(function() {
        shader.set({
          fragment: o.src()
        });
        return draw();
      });
      ko.computed(function() {
        var uniformValues;
        uniformValues = {};
        uniformValues.boundsMin = [o.bounds().minX, o.bounds().minY];
        uniformValues.boundsMax = [o.bounds().maxX, o.bounds().maxY];
        shader.set({
          uniforms: uniformValues
        });
        return draw();
      });
      return ko.computed(function() {
        var name, uniform, uniformValues, uniforms;
        uniforms = o.uniforms();
        uniformValues = {};
        for (name in uniforms) {
          if (!__hasProp.call(uniforms, name)) continue;
          uniform = uniforms[name];
          if (uniform.value !== void 0) {
            uniformValues[name] = uniform.value;
          }
        }
        shader.set({
          uniforms: uniformValues
        });
        return draw();
      });
    }
  };

}).call(this);
