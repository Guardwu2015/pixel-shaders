// Generated by CoffeeScript 1.4.0
(function() {
  var $, XRegExp, clear, floatToString, ko, makeShaderExample, parseUniforms, rafAnimate, sizeCanvas, startTime, templates, updateUniforms, vecToString, vertexShaderSource, _,
    __hasProp = {}.hasOwnProperty;

  ko = require("knockout");

  $ = require("jquery");

  _ = require("underscore");

  clear = function(ctx) {
    var h, w;
    w = ctx.canvas.width;
    h = ctx.canvas.height;
    return ctx.clearRect(0, 0, w, h);
  };

  sizeCanvas = function(canvas) {
    var h, w;
    w = $(canvas).width();
    h = $(canvas).height();
    canvas.width = w;
    return canvas.height = h;
  };

  rafAnimate = function(callback) {
    var animate;
    animate = function() {
      require("raf")(animate);
      return callback();
    };
    return animate();
  };

  ko.bindingHandlers.drawGrid = {
    init: function(element, valueAccessor) {
      var ctx, draw, o;
      o = valueAccessor();
      sizeCanvas(element);
      ctx = element.getContext("2d");
      draw = function() {
        var bounds, opts;
        clear(ctx);
        bounds = o.bounds();
        opts = {
          ctx: ctx,
          minX: bounds.minX,
          maxX: bounds.maxX,
          minY: bounds.minY,
          maxY: bounds.maxY,
          flipY: true,
          color: "0,0,0",
          shadow: false
        };
        if (o.color === "white") {
          opts.color = "255,255,255";
          opts.shadow = true;
        } else if (o.color === "black") {
          opts.color = "0,0,0";
          opts.shadow = false;
        }
        return require("graph-grid")(opts);
      };
      return ko.computed(draw);
    }
  };

  ko.bindingHandlers.panAndZoom = {
    init: function(element, valueAccessor) {
      var o, pz;
      o = valueAccessor();
      pz = require("pan-zoom")({
        element: element,
        flipY: true
      });
      ko.computed(function() {
        var bounds;
        bounds = o.bounds();
        pz.minX = bounds.minX;
        pz.maxX = bounds.maxX;
        pz.minY = bounds.minY;
        return pz.maxY = bounds.maxY;
      });
      return pz.on("update", function() {
        return o.bounds({
          minX: pz.minX,
          maxX: pz.maxX,
          minY: pz.minY,
          maxY: pz.maxY
        });
      });
    }
  };

  XRegExp = require('xregexp').XRegExp;

  parseUniforms = function(src) {
    var regex, uniforms;
    regex = XRegExp('uniform +(?<type>[^ ]+) +(?<name>[^ ;]+) *;', 'g');
    uniforms = {};
    XRegExp.forEach(src, regex, function(match) {
      return uniforms[match.name] = {
        type: match.type
      };
    });
    return uniforms;
  };

  ko.bindingHandlers.editorShader = {
    init: function(element, valueAccessor) {
      var editor, o;
      o = valueAccessor();
      editor = require("editor")({
        div: element,
        src: o.src(),
        multiline: true
      });
      editor.on("change", function() {
        o.compiled(false);
        return o.src(editor.src());
      });
      ko.computed(function() {
        var compiled, errors, src;
        src = o.src();
        errors = require("glsl-error")(src);
        editor.set({
          errors: errors
        });
        compiled = !_.some(errors);
        return o.compiled(compiled);
      });
      return ko.computed(function() {
        var src;
        if (o.compiled()) {
          src = o.src();
          return o.uniforms(parseUniforms(src));
        }
      });
    }
  };

  ko.bindingHandlers.editorLine = {
    init: function(element, valueAccessor) {
      var editor, o;
      o = valueAccessor();
      editor = require("editor")({
        div: element,
        src: o.src(),
        multiline: false
      });
      return editor.on("change", function() {
        return o.src(editor.src());
      });
    }
  };

  vertexShaderSource = "precision mediump float;\n\nattribute vec3 vertexPosition;\nvarying vec2 position;\nuniform vec2 boundsMin;\nuniform vec2 boundsMax;\n\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  position = mix(boundsMin, boundsMax, (vertexPosition.xy + 1.0) * 0.5);\n}";

  ko.bindingHandlers.drawShader = {
    init: function(element, valueAccessor) {
      var draw, o, shader;
      o = valueAccessor();
      shader = require("shader")({
        canvas: element,
        vertex: vertexShaderSource,
        fragment: o.src()
      });
      draw = function() {
        return shader.draw();
      };
      ko.computed(function() {
        if (o.compiled()) {
          shader.set({
            fragment: o.src()
          });
          return draw();
        }
      });
      ko.computed(function() {
        var uniformValues;
        uniformValues = {};
        uniformValues.boundsMin = [o.bounds().minX, o.bounds().minY];
        uniformValues.boundsMax = [o.bounds().maxX, o.bounds().maxY];
        shader.set({
          uniforms: uniformValues
        });
        return draw();
      });
      return ko.computed(function() {
        var name, uniform, uniformValues, uniforms;
        uniforms = o.uniforms();
        uniformValues = {};
        for (name in uniforms) {
          if (!__hasProp.call(uniforms, name)) continue;
          uniform = uniforms[name];
          if (uniform.value !== void 0) {
            uniformValues[name] = uniform.value;
          }
        }
        shader.set({
          uniforms: uniformValues
        });
        return draw();
      });
    }
  };

  startTime = Date.now();

  updateUniforms = function(uniformsObservable) {
    var changed, name, uniform, uniforms;
    uniforms = uniformsObservable();
    changed = false;
    for (name in uniforms) {
      if (!__hasProp.call(uniforms, name)) continue;
      uniform = uniforms[name];
      if (name === "time" && uniform.type === "float") {
        uniform.value = (Date.now() - startTime) / 1000;
        changed = true;
      } else if (name === "webcam" && uniform.type === "sampler2D") {
        uniform.value = require("webcam")();
        changed = true;
      }
    }
    if (changed) {
      return uniformsObservable(uniforms);
    }
  };

  templates = {
    shaderExample: "<div class=\"book-view-edit\">\n  <div class=\"book-view\" data-bind=\"panAndZoom: {bounds: bounds}\">\n    <canvas data-bind=\"drawShader: {bounds: bounds, src: src, compiled: compiled, uniforms: uniforms}\"></canvas>\n    <canvas class=\"book-grid\" data-bind=\"drawGrid: {bounds: bounds, color: 'white'}\"></canvas>\n  </div>\n  <div class=\"book-edit book-editor\" data-bind=\"editorShader: {src: src, compiled: compiled, uniforms: uniforms}\">\n  </div>\n</div>"
  };

  makeShaderExample = function(src) {
    var fragmentShaderSource, model;
    fragmentShaderSource = "precision mediump float;\n\nvarying vec2 position;\n\nvoid main() {\n  gl_FragColor.r = position.x;\n  gl_FragColor.g = position.y;\n  gl_FragColor.b = 0.0;\n  gl_FragColor.a = 1.0;\n}";
    model = {
      bounds: ko.observable({
        minX: 0,
        minY: 0,
        maxX: 1,
        maxY: 1
      }),
      src: ko.observable(fragmentShaderSource),
      compiled: ko.observable(false),
      uniforms: ko.observable({})
    };
    return rafAnimate(function() {
      return updateUniforms(model.uniforms);
    });
  };

  floatToString = function(n, significantDigits) {
    return n.toPrecision(significantDigits);
  };

  vecToString = function(x, significantDigits) {
    var fts, n, s;
    fts = function(n) {
      return floatToString(n, significantDigits);
    };
    if (x.length === 1) {
      return fts(x[0]);
    } else {
      s = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          n = x[_i];
          _results.push(fts(n));
        }
        return _results;
      })()).join(", ");
      return "vec" + x.length + "(" + s + ")";
    }
  };

  (function() {
    var model;
    model = {
      src: ko.observable("3. + 5."),
      result: ko.observable("")
    };
    ko.computed(function() {
      var ast, result, src;
      src = model.src();
      try {
        ast = require("parse-glsl").parse(src, "assignment_expression");
        console.log(ast);
        require("interpret")({}, ast);
        result = vecToString(ast.evaluated, 3);
        console.log(result);
        return model.result(result);
      } catch (_error) {}
    });
    return ko.applyBindings(model);
  })();

}).call(this);
