// Generated by CoffeeScript 1.4.0
(function() {
  var drawLine, findSpacing, map, ticks;

  map = function(x, dMin, dMax, rMin, rMax) {
    var ratio;
    ratio = (x - dMin) / (dMax - dMin);
    return ratio * (rMax - rMin) + rMin;
  };

  findSpacing = function(minSpacing) {
    /*
      need to determine:
        largeSpacing = {1, 2, or 5} * 10^n
        smallSpacing = divide largeSpacing by 4 (if 1 or 2) or 5 (if 5)
      largeSpacing must be greater than minSpacing
    */

    var div, largeSpacing, smallSpacing, z;
    div = 4;
    largeSpacing = z = Math.pow(10, Math.ceil(Math.log(minSpacing) / Math.log(10)));
    if (z / 5 > minSpacing) {
      largeSpacing = z / 5;
    } else if (z / 2 > minSpacing) {
      largeSpacing = z / 2;
      div = 5;
    }
    smallSpacing = largeSpacing / div;
    return [largeSpacing, smallSpacing];
  };

  ticks = function(spacing, min, max) {
    var first, last, x, _i, _results;
    first = Math.ceil(min / spacing);
    last = Math.floor(max / spacing);
    _results = [];
    for (x = _i = first; first <= last ? _i <= last : _i >= last; x = first <= last ? ++_i : --_i) {
      _results.push(x * spacing);
    }
    return _results;
  };

  drawLine = function(ctx, _arg, _arg1) {
    var x1, x2, y1, y2;
    x1 = _arg[0], y1 = _arg[1];
    x2 = _arg1[0], y2 = _arg1[1];
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    return ctx.stroke();
  };

  module.exports = function(opts) {
    var axesColor, axesOpacity, cMaxX, cMaxY, cMinX, cMinY, canvas, color, ctx, cx, cy, fromLocal, height, labelColor, labelDistance, labelOpacity, largeSpacing, majorColor, majorOpacity, maxX, maxY, minPixels, minSpacing, minX, minY, minorColor, minorOpacity, shadowBlur, shadowCol, shadowColor, shadowOpacity, sizeX, sizeY, smallSpacing, text, textHeight, toLocal, width, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    ctx = opts.ctx;
    minX = opts.minX;
    maxX = opts.maxX;
    minY = opts.minY;
    maxY = opts.maxY;
    sizeX = maxX - minX;
    sizeY = maxY - minY;
    canvas = ctx.canvas;
    width = canvas.width;
    height = canvas.height;
    cMinX = 0;
    cMaxX = width;
    cMinY = 0;
    cMaxY = height;
    if (opts.flipX) {
      _ref = [cMaxX, cMinX], cMinX = _ref[0], cMaxX = _ref[1];
    }
    if (opts.flipY) {
      _ref1 = [cMaxY, cMinY], cMinY = _ref1[0], cMaxY = _ref1[1];
    }
    toLocal = function(_arg) {
      var cx, cy;
      cx = _arg[0], cy = _arg[1];
      return [map(cx, cMinX, cMaxX, minX, maxX), map(cy, cMinY, cMaxY, minY, maxY)];
    };
    fromLocal = function(_arg) {
      var x, y;
      x = _arg[0], y = _arg[1];
      return [map(x, minX, maxX, cMinX, cMaxX), map(y, minY, maxY, cMinY, cMaxY)];
    };
    minPixels = 70;
    labelDistance = 5;
    color = opts.color;
    minorOpacity = 0.2;
    majorOpacity = 0.4;
    axesOpacity = 1.0;
    labelOpacity = 1.0;
    textHeight = 12;
    shadowColor = "0,0,0";
    shadowOpacity = 0.8;
    shadowBlur = 3;
    minorColor = "rgba(" + color + ", " + minorOpacity + ")";
    majorColor = "rgba(" + color + ", " + majorOpacity + ")";
    axesColor = "rgba(" + color + ", " + axesOpacity + ")";
    labelColor = "rgba(" + color + ", " + labelOpacity + ")";
    shadowCol = "rgba(" + shadowColor + ", " + shadowOpacity + ")";
    minSpacing = (sizeX / width) * minPixels;
    _ref2 = findSpacing(minSpacing), largeSpacing = _ref2[0], smallSpacing = _ref2[1];
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.lineWidth = 0.5;
    if (opts.shadow) {
      ctx.shadowColor = shadowCol;
      ctx.shadowBlur = shadowBlur;
    }
    ctx.strokeStyle = minorColor;
    _ref3 = ticks(smallSpacing, minX, maxX);
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      x = _ref3[_i];
      drawLine(ctx, fromLocal([x, minY]), fromLocal([x, maxY]));
    }
    _ref4 = ticks(smallSpacing, minY, maxY);
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      y = _ref4[_j];
      drawLine(ctx, fromLocal([minX, y]), fromLocal([maxX, y]));
    }
    ctx.strokeStyle = majorColor;
    _ref5 = ticks(largeSpacing, minX, maxX);
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      x = _ref5[_k];
      drawLine(ctx, fromLocal([x, minY]), fromLocal([x, maxY]));
    }
    _ref6 = ticks(largeSpacing, minY, maxY);
    for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
      y = _ref6[_l];
      drawLine(ctx, fromLocal([minX, y]), fromLocal([maxX, y]));
    }
    ctx.strokeStyle = axesColor;
    drawLine(ctx, fromLocal([0, minY]), fromLocal([0, maxY]));
    drawLine(ctx, fromLocal([minX, 0]), fromLocal([maxX, 0]));
    ctx.font = "" + textHeight + "px verdana";
    ctx.fillStyle = labelColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    _ref7 = ticks(largeSpacing, minX, maxX);
    for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
      x = _ref7[_m];
      if (x !== 0) {
        text = parseFloat(x.toPrecision(12)).toString();
        _ref8 = fromLocal([x, 0]), cx = _ref8[0], cy = _ref8[1];
        cy += labelDistance;
        if (cy < labelDistance) {
          cy = labelDistance;
        }
        if (cy + textHeight + labelDistance > height) {
          cy = height - labelDistance - textHeight;
        }
        ctx.fillText(text, cx, cy);
      }
    }
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    _ref9 = ticks(largeSpacing, minY, maxY);
    for (_n = 0, _len5 = _ref9.length; _n < _len5; _n++) {
      y = _ref9[_n];
      if (y !== 0) {
        text = parseFloat(y.toPrecision(12)).toString();
        _ref10 = fromLocal([0, y]), cx = _ref10[0], cy = _ref10[1];
        cx += labelDistance;
        if (cx < labelDistance) {
          cx = labelDistance;
        }
        if (cx + ctx.measureText(text).width + labelDistance > width) {
          cx = width - labelDistance - ctx.measureText(text).width;
        }
        ctx.fillText(text, cx, cy);
      }
    }
    ctx.restore();
    return {};
  };

}).call(this);
